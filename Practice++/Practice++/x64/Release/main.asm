; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_06MDBPMDDK@Cherno?$AA@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp_memmove:PROC
EXTRN	__security_check_cookie:PROC
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB DQ ffffffffffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDBPMDDK@Cherno?$AA@
CONST	SEGMENT
??_C@_06MDBPMDDK@Cherno?$AA@ DB 'Cherno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
PUBLIC	??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z ; std::allocator<char>::destroy<char * __ptr64>
PUBLIC	??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * __ptr64 & __ptr64>
PUBLIC	??$_Addressof@D@std@@YAPEADAEADU?$integral_constant@_N$0A@@0@@Z ; std::_Addressof<char>
PUBLIC	??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const & __ptr64>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> & __ptr64>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?max_size@?$allocator@D@std@@QEBA_KXZ		; std::allocator<char>::max_size
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$allocator@D@std@@QEAA@AEBV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_NPEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAPEADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAPEBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEB_KXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??1Entity@@QEAA@XZ				; Entity::~Entity
PUBLIC	main
PUBLIC	?GetName@Entity@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Entity::GetName
PUBLIC	??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Entity::Entity
PUBLIC	??0Entity@@QEAA@XZ				; Entity::Entity
PUBLIC	?_Deallocate@std@@YAXPEAX_K1@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPEAX_K0_N@Z			; std::_Allocate
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAEADAEBD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SA_KPEBD@Z		; std::char_traits<char>::length
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	memcpy:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4@endl
	DD	imagerel $LN4@endl+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN143@operator
	DD	imagerel $LN143@operator+458
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DD imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+56
	DD	imagerel $unwind$?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN15@allocate
	DD	imagerel $LN15@allocate+111
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10@Sentry_bas
	DD	imagerel $LN10@Sentry_bas+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8@Sentry_bas
	DD	imagerel $LN8@Sentry_bas+49
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z DD imagerel $LN18@allocate
	DD	imagerel $LN18@allocate+111
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN26@sentry
	DD	imagerel $LN26@sentry+124
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13@sentry
	DD	imagerel $LN13@sentry+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z DD imagerel $LN14@deallocate
	DD	imagerel $LN14@deallocate+98
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel $LN510@Copy
	DD	imagerel $LN510@Copy+443
	DD	imagerel $unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+47
	DD	imagerel $unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+159
	DD	imagerel $unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN50@erase
	DD	imagerel $LN50@erase+62
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN125@erase
	DD	imagerel $LN125@erase+163
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104@Grow
	DD	imagerel $LN104@Grow+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104@Grow+29
	DD	imagerel $LN104@Grow+68
	DD	imagerel $chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104@Grow+68
	DD	imagerel $LN104@Grow+107
	DD	imagerel $chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4@Xlen
	DD	imagerel $LN4@Xlen+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4@Xran
	DD	imagerel $LN4@Xran+18
	DD	imagerel $unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z DD imagerel $LN17@deallocate
	DD	imagerel $LN17@deallocate+98
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN381@assign
	DD	imagerel $LN381@assign+373
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z DD imagerel $LN232@assign
	DD	imagerel $LN232@assign+301
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN132@Tidy
	DD	imagerel $LN132@Tidy+187
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN159
	DD	imagerel $LN159+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z DD imagerel $LN153
	DD	imagerel $LN153+60
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN135@basic_stri
	DD	imagerel $LN135@basic_stri+146
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Entity@@QEAA@XZ DD imagerel $LN139@Entity
	DD	imagerel $LN139@Entity+146
	DD	imagerel $unwind$??1Entity@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN886
	DD	imagerel $LN886+609
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN163
	DD	imagerel $LN163+49
	DD	imagerel $unwind$??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Entity@@QEAA@XZ DD imagerel $LN156
	DD	imagerel $LN156+62
	DD	imagerel $unwind$??0Entity@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN11@Deallocate
	DD	imagerel $LN11@Deallocate+95
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN12@Allocate
	DD	imagerel $LN12@Allocate+111
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DD imagerel $LN7@copy
	DD	imagerel $LN7@copy+28
	DD	imagerel $unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Entity@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DD imagerel main
	DD	0ffffffffH
	DD	imagerel main+84
	DD	00H
	DD	imagerel main+152
	DD	01H
	DD	imagerel main+188
	DD	03H
	DD	imagerel main+354
	DD	00H
	DD	imagerel main+474
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DD 0ffffffffH
	DD	imagerel main$dtor$0
	DD	00H
	DD	imagerel main$dtor$1
	DD	01H
	DD	imagerel main$dtor$2
	DD	00H
	DD	imagerel main$dtor$2
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$main DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$main
	DD	00H
	DD	00H
	DD	06H
	DD	imagerel $ip2state$main
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	052c19H
	DD	016341eH
	DD	014010eH
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$main
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Entity@@QEAA@XZ DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DQ 00007640f00060f01r ; 1.02782e-308
	DQ	0700b320f0006340fr		; 5.2777e+231
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z DQ 00007640f00060f01r ; 1.02782e-308
	DQ	0700b320f0006340fr		; 5.2777e+231
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DQ 00008741500081501r ; 1.1756e-308
	DQ	00006341500076415r		; 8.62695e-309
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DQ 00006740000020021r ; 8.97417e-309
	DD	imagerel $LN104@Grow
	DD	imagerel $LN104@Grow+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DQ 00006740500020521r ; 8.97428e-309
	DD	imagerel $LN104@Grow
	DD	imagerel $LN104@Grow+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DQ 00006340a00040a01r ; 8.62672e-309
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DQ 05007420b00030b19r ; 3.36636e+77
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DQ 05006320a00020a19r ; 3.21257e+77
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	0ffffffffH
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+110
	DD	00H
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+213
	DD	0ffffffffH
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+21
	DD	02H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+33
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+14
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 00000000000000000r ; 0
	DQ	00000000100000003r		; 2.122e-314
	DD	imagerel $handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DQ	00000000200000002r		; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	imagerel $handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 000000000ffffffffr ; 2.122e-314
	DQ	000000000ffffffffr		; 2.122e-314
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 00000000419930522r ; 8.69997e-314
	DD	imagerel $stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	imagerel $tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	08H
	DD	imagerel $ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DQ 0e014621800052119r ; -6.83234e+154
	DQ	00000301060117012r		; 2.61098e-310
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000000r		; 0
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000020r		; 1.58101e-322
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 03002520600020f19r ; 1.97773e-77
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+57
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DQ	00000000000000000r		; 0
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DQ 00009341800041811r ; 1.2799e-308
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DQ	00000000000000020r		; 1.58101e-322
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DQ 00000620400010d19r ; 5.32451e-310
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DQ 05006320a00020a19r ; 3.21257e+77
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+104
	DD	00H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+158
	DD	01H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+172
	DD	02H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+352
	DD	01H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+390
	DD	04H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+410
	DD	05H
	DD	imagerel ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+434
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	imagerel ?catch$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	imagerel $handlerMap$0$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$5@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	imagerel ?dtor$15@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$16@?0???$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00000000619930522r ; 1.2944e-313
	DD	imagerel $stateUnwindMap$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DQ	00000000000000020r		; 1.58101e-322
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DQ 00010342200082219r ; 2.25339e-308
	DQ	0c009e00bf00d7211r		; -3.2344
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
; Function compile flags: /Ogtpy
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
;	COMDAT ??0Entity@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0Entity@@QEAA@XZ PROC					; Entity::Entity, COMDAT

; 10   : 	Entity() : m_Name("Unknown"),m_Score(0){

$LN156:
	push	rbx
	sub	rsp, 32					; 00000020H
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown?$AA@

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 7
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 10   : 	Entity() : m_Name("Unknown"),m_Score(0){

	mov	rbx, rcx
; File g:\vb.net\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 11   : 	}

	mov	rax, rbx
	mov	DWORD PTR [rbx+32], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0Entity@@QEAA@XZ ENDP					; Entity::Entity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
;	COMDAT ??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 48
name$ = 56
??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Entity::Entity, COMDAT

; 12   : 	Entity(const std::string& name):m_Name(name) {

$LN163:
	push	rbx
	sub	rsp, 32					; 00000020H
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 770  : 		assign(_Right, 0, npos);

	or	r9, -1

; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0

; 770  : 		assign(_Right, 0, npos);

	xor	r8d, r8d
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 12   : 	Entity(const std::string& name):m_Name(name) {

	mov	rbx, rcx
; File g:\vb.net\vc\include\xstring

; 770  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 13   : 	}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0Entity@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Entity::Entity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\xmemory0
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\xmemory0
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\xmemory0
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp
;	COMDAT main
_TEXT	SEGMENT
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main	PROC						; COMDAT

; 19   : int main() {

$LN886:
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T204[rbp-73], -2
	mov	QWORD PTR [rsp+176], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-73], rax
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR e0$[rbp-49], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	xor	ebx, ebx
	mov	QWORD PTR e0$[rbp-57], rbx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR e0$[rbp-73], bl
; File g:\vb.net\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+7]
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown?$AA@
	lea	rcx, QWORD PTR e0$[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 10   : 	Entity() : m_Name("Unknown"),m_Score(0){

	mov	DWORD PTR e0$[rbp-41], ebx

; 20   : 	Entity e0;
; 21   : 	std::cout << e0.GetName() << std::endl;

	lea	rdx, QWORD PTR e0$[rbp-73]
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T35[rbp-49], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR $T35[rbp-57], rbx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T35[rbp-73], bl
; File g:\vb.net\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rbx+6]
	lea	rdx, OFFSET FLAT:??_C@_06MDBPMDDK@Cherno?$AA@
	lea	rcx, QWORD PTR $T35[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR e1$[rbp-49], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR e1$[rbp-57], rbx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR e1$[rbp-73], bl
; File g:\vb.net\vc\include\xstring

; 770  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T35[rbp-73]
	lea	rcx, QWORD PTR e1$[rbp-73]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR $T35[rbp-49]
	cmp	rax, 16
	jb	SHORT $LN561@main

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File g:\vb.net\vc\include\xmemory0

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR $T35[rbp-73]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, -1
	jbe	SHORT $LN555@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN555@main:

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN556@main

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR $T35[rbp-73], 31
	je	SHORT $LN557@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN557@main:

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN558@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN558@main:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN559@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN559@main:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN560@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN560@main:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN556@main:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN561@main:
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T35[rbp-49], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR $T35[rbp-57], rbx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T35[rbp-73], 0
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 24   : 	std::cout << e1.GetName() << std::endl;

	lea	rdx, QWORD PTR e1$[rbp-73]
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 25   : 	std::cin.get();

	mov	rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAHXZ
	npad	1
; File g:\vb.net\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR e1$[rbp-49]
	cmp	rax, 16
	jb	SHORT $LN699@main

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File g:\vb.net\vc\include\xmemory0

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR e1$[rbp-73]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, -1
	jbe	SHORT $LN693@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN693@main:

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN694@main

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR e1$[rbp-73], 31
	je	SHORT $LN695@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN695@main:

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN696@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN696@main:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN697@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN697@main:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN698@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN698@main:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN694@main:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN699@main:
; File g:\vb.net\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR e1$[rbp-49], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR e1$[rbp-57], rbx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR e1$[rbp-73], 0
; File g:\vb.net\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR e0$[rbp-49]
	cmp	rax, 16
	jb	SHORT $LN836@main

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File g:\vb.net\vc\include\xmemory0

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR e0$[rbp-73]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, -1
	jbe	SHORT $LN830@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN830@main:

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN831@main

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR e0$[rbp-73], 31
	je	SHORT $LN832@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN832@main:

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN833@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN833@main:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN834@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN834@main:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN835@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN835@main:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN831@main:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN836@main:
; File g:\github\nkuzmic97\practice.cpp\practice++\practice++\main.cpp

; 26   : }

	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-73]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 160				; 000000a0H
	pop	rbp
	ret	0
$LN885@main:
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$0 PROC
	lea	rcx, QWORD PTR e0$[rdx]
	jmp	??1Entity@@QEAA@XZ
main$dtor$0 ENDP
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$1 PROC
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$2 PROC
	lea	rcx, QWORD PTR e1$[rdx]
	jmp	??1Entity@@QEAA@XZ
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$0 PROC
	lea	rcx, QWORD PTR e0$[rdx]
	jmp	??1Entity@@QEAA@XZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$1 PROC
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T204 = 32
$T35 = 40
e1$ = 72
e0$ = 112
__$ArrayPad$ = 152
main$dtor$2 PROC
	lea	rcx, QWORD PTR e1$[rdx]
	jmp	??1Entity@@QEAA@XZ
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 824  : 		{	// construct from [_Ptr, <null>)

$LN153:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	xor	r8d, r8d

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r8

; 824  : 		{	// construct from [_Ptr, <null>)

	mov	rbx, rcx
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [rcx], r8b

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [rdx], r8b
	je	SHORT $LN150@basic_stri
	or	r8, -1
$LL151@basic_stri:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL151@basic_stri
$LN150@basic_stri:
; File g:\vb.net\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\iosfwd
; File g:\vb.net\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 768  : 		{	// construct by copying _Right

$LN159:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);

	or	r9, -1

; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], 0

; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);

	xor	r8d, r8d
; File g:\vb.net\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [rcx], 0
; File g:\vb.net\vc\include\xstring

; 768  : 		{	// construct by copying _Right

	mov	rbx, rcx

; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 771  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 829  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 830  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 680  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 681  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 488  : 		_Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 489  : 		_Myres = 0;

	mov	QWORD PTR [rcx+24], rax

; 578  : 		}

	mov	rax, rcx
	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 294  : 		return (*this);

	mov	rax, rcx

; 295  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 791  : 		return (_Al);

	mov	rax, rcx

; 792  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> & __ptr64>, COMDAT

; 1250 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	rax, rcx

; 1251 : 	}

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\xutility
; File g:\vb.net\vc\include\xstring
; File g:\vb.net\vc\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File g:\vb.net\vc\include\xstring

; 488  : 		_Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 489  : 		_Myres = 0;

	mov	QWORD PTR [rcx+24], rax
; File g:\vb.net\vc\include\xutility

; 289  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\vb.net\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1235 : 	}

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
END
